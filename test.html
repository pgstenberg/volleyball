<html>

<head>

  <style>
  canvas {
      border: 3px solid #333;
  }
  </style>

   <script type = "text/javascript">

   ws_open = false;
  


         if ("WebSocket" in window) {

            // Let us open a web socket
            var ws = new WebSocket("ws://127.0.0.1:8080/");

            ws.onopen = function() {
              ws_open = true;
            };

            ws.onmessage = function (evt) {
              if (typeof playerID === 'undefined') {
                playerID = evt.data;
                console.log("New Player ID: " + playerID);
                return;
              }

              d = JSON.parse(evt.data);

              if(playerID in d['Players']){

                /*
                console.log("SEQ: " + d['Players'][playerID]['LastSequenceNumber']);
                console.log("X1: " + snapshot[d['Players'][playerID]['LastSequenceNumber']].x + " Y1: " + snapshot[d['Players'][playerID]['LastSequenceNumber']].y);
                console.log("X2: " + d['Players'][playerID]['PosX'] + " Y2: " + d['Players'][playerID]['PosY']);
                console.log("");
                */


                if((snapshot[d['Players'][playerID]['LastSequenceNumber']].x !== d['Players'][playerID]['PosX'])){
                  //player.position.x = d['Players'][playerID]['PosX'];
                }

                if(snapshot[d['Players'][playerID]['LastSequenceNumber']].y !== d['Players'][playerID]['PosY']){
                  //player.position.y = d['Players'][playerID]['PosY'];
                }
              }

            };

            ws.onclose = function() {
              ws_open = false;
            };
         } else {

            // The browser doesn't support WebSocket
            alert("WebSocket NOT supported by your Browser!");
         }
   </script>

</head>

<body>

  <canvas id='tutorial' width='300' height='300'></canvas>

<script>


var player = {
  input: { left: false, right: false, jump: false },
  state: [false, false, false],
  position: { x: 0, y: 0},
  velocity: { x: 0, y: 0}
}

var seqNumber = 0;
var playerID;

var snapshot = [];
var jumpInputs = 0;

var CLIENT_TICK_RATE = 60;
var PLAYER_SPEED = 4 * CLIENT_TICK_RATE;
var GRAVITY = 4 * CLIENT_TICK_RATE;
var PLAYER_JUMP_SPEED = GRAVITY * 3;
var MAX_JUMP_INPUTS = 10;

var STATE_MOVING_LEFT = 0;
var STATE_MOVING_RIGHT = 1;
var STATE_JUMPING = 2;

var canvas = document.getElementById('tutorial'),
    ctx    = canvas.getContext('2d'),
    invalid = true,   // component requires redrawing ?
    cache   = null;   // cached off-screen canvas

    function renderToCanvas(width, height, render, canvas) {
      canvas = canvas || createCanvas(width, height, canvas);
      render(canvas.getContext('2d'));
      return canvas;
    }

    function createCanvas(width, height) {
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }

var KEY = {
    BACKSPACE: 8,
    TAB:       9,
    RETURN:   13,
    ESC:      27,
    SPACE:    32,
    PAGEUP:   33,
    PAGEDOWN: 34,
    END:      35,
    HOME:     36,
    LEFT:     37,
    UP:       38,
    RIGHT:    39,
    DOWN:     40,
    INSERT:   45,
    DELETE:   46,
    ZERO:     48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57,
    A:        65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90,
    TILDA:    192
  };

document.addEventListener('keydown', function(ev) { return onkey(ev, ev.keyCode, true);  }, false);
document.addEventListener('keyup',   function(ev) { return onkey(ev, ev.keyCode, false); }, false);

function onkey(ev, key, pressed) {
  switch(key) {
    case KEY.LEFT:  player.input.left  = pressed; ev.preventDefault(); break;
    case KEY.RIGHT: player.input.right = pressed; ev.preventDefault(); break;
    case KEY.SPACE: player.input.jump  = pressed; ev.preventDefault(); break;
  }
}


function timestamp() {
  return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
}

function update(dt){




  if(ws_open){

      var _input = []

      if(player.input.left){
        player.state[STATE_MOVING_LEFT] = true;
        _input.push("01");
      }else if(player.input.right){
        player.state[STATE_MOVING_RIGHT] = true;
        _input.push("02");
      }

      if(player.input.jump){
          if(jumpInputs <= MAX_JUMP_INPUTS && player.velocity.y >= 0){
            player.state[STATE_JUMPING] = true;
            _input.push("03");
            jumpInputs += 1;
          }
      }else{
        if(player.position.y === 0 && jumpInputs > 0){
          jumpInputs = 0;
          _input.push("04");
        }
      }
      

      if(player.state[STATE_MOVING_LEFT]){
        player.velocity.x = -PLAYER_SPEED;
      }else if(player.state[STATE_MOVING_RIGHT]){
        player.velocity.x = PLAYER_SPEED;
      }

      if(player.state[STATE_JUMPING]) {
        player.velocity.y = PLAYER_JUMP_SPEED;
      }

      if(player.position.y > 0){
        player.velocity.y -= GRAVITY;
      }
      
      player.position.x += Math.round(player.velocity.x * dt);
      player.position.y += Math.round(player.velocity.y * dt);

      if(player.position.y < 0){
        player.position.y = 0;
        player.velocity.y = 0;
      }

      if(player.position.y > 0){
        console.log("INPUT " + jumpInputs);
        console.log("Y: " + player.position.y);
        console.log("");
      }

      player.state[STATE_MOVING_LEFT] = false;
      player.state[STATE_MOVING_RIGHT] = false;
      player.state[STATE_JUMPING] = false;
      player.velocity.x = 0;

      if(_input.length !== 0){
        snapshot[seqNumber] = player.position
        input_package = seqNumber + ";" + _input.join(";");
        ws.send(input_package);
        seqNumber++;
      }
      

  }

}
function render(ctx){
  if (invalid) {

    cache = renderToCanvas(600, 300, renderForReal, cache);
    invalid = false;
  }
  ctx.drawImage(cache, x, 0);
}

function renderForReal(ctx) {
  ctx.fillStyle   = '#FF0000';
  ctx.strokeStyle = '#00FF00';
  ctx.clearRect(0, 0, 600, 300);
  ctx.beginPath();
  ctx.fillRect(player.position.x, 300 - player.position.y - 25, 25, 25);
  ctx.strokeRect(player.position.x, 300 - player.position.y - 25, 25, 25);
}

var now,
    dt   = 0,
    last = timestamp(),
    step = 1/60;

function frame() {
  now = timestamp();
  dt = dt + Math.min(1, (now - last) / 1000);
  while(dt > step) {
    dt = dt - step;
    update(step);
  }
  renderForReal(ctx);
  last = now;
  requestAnimationFrame(frame);
}

requestAnimationFrame(frame);

</script>

</body>

</html>
